# The problem input consists of a single line of
# text that includes a row and column position for
# looking up a code. The codes are printed on an
# infinite sheet of paper, starting in the top-
# left corner. The codes are filled in by
# diagonals: starting with the first row with an
# empty first box, the codes are filled in
# diagonally up and to the right. This process
# repeats until the infinite paper is covered. The
# first code is 20151125. After that, each code is
# generated by taking the previous one,
# multiplying it by 252533, and then keeping the
# remainder from dividing that value by 33554393.
#
# The puzzle input contains the message on the
# machine's console. What code do you give the
# machine?

import time          # For timing the execution

# Read in the data file and convert it to a list
# of strings.
def readFile(filename):
   lines = []
   try:
      with open(filename, "r") as file:
         line = file.readline()
         while line:
            lines.append(line.replace('\n', ''))
            line = file.readline()

         file.close()
            
   except FileNotFoundError:
      print("Error: File not found!")
   except:
      print("Error: Can't read from file!")

   # Only need the first number (as a string).
   return lines



# Take the file input, split out the row and
# column data, convert each to integer, and return
# those values.
def parseInput(values):
   # Remove all commas and periods from the input.
   values = values.replace(',', '')
   values = values.replace('.', '')

   # Find the row and column data by spliting the
   # input string and convert each to integer.
   parts = values.split()
   row = int(parts[15])
   column = int(parts[17])

   # Return the row and column
   return (row, column)


if __name__ == '__main__':
   # Start the timer
   start_time = time.time()

   # Read the input file and convert it to a list
   # of weights.
   file_input = readFile("input25b.txt")[0]
   row, column = parseInput(file_input)

   # The first code.
   code = 20151125

   # Continue to iterate through code generation
   # until the correct code is reached.
   y = 0
   while True:
      # Initialize the starting row and column for
      # this diagonal.
      my_row = y
      my_col = 1

      # Iterate through the number of codes that
      # need to be generated along the diagonal.
      for x in range(y):
         # If the correct row and column is
         # reached, then break out of the loop.
         if (my_row == row) and (my_col == column):
            break

         # Otherwise, generate the next code and
         # update row and column values for this
         # digonal.
         code = (code * 252533) % 33554393
         my_row -= 1
         my_col += 1

      # If the inner loop finished without a
      # 'break', then update y and loop again.
      else:
         y += 1
         continue

      # Otherwise, break out of the outer loop.
      break

   # Display the generated code.
   print('Correct code = ' + str(code))

   # Stop the timer and print the execution time.
   print("\n\n--- %s seconds ---" % (time.time() - start_time))
